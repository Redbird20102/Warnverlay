<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Weather Alert System</title>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet" />
  <style>
    /* Basic Page Styles */
    body {
      margin: 0;
      padding: 0;
      background: black;
      font-family: Arial, sans-serif;
      background-size: cover;
      transition: background 1s ease-in-out;
    }
    
    /* Menu Icon Styles */
    #menu-icon {
      position: fixed;
      top: 10px;
      left: 10px;
      width: 100px;
      height: 100px;
      cursor: pointer;
      z-index: 400;
      /* Optional: a semi-transparent background circle */
      background-color: rgba(0,0,0,0.6);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #menu-icon span {
      display: block;
      width: 24px;
      height: 3px;
      background: white;
      margin: 3px 0;
      transition: 0.4s;
    }
    
    /* Sidebar Menu Styles */
    #alert-menu {
      position: fixed;
      top: 60px;
      left: 10px;
      width: 500px;
      background: rgba(0, 0, 0, 0.85);
      padding: 10px;
      border-radius: 5px;
      z-index: 300;
      display: none;  /* Initially hidden */
      max-height: 80vh;
      overflow-y: auto;
    }
    .menu-group {
      margin-bottom: 20px;
    }
    .menu-group h3 {
      margin: 20px 0 5px;
      font-family: 'Bebas Neue', sans-serif;
      font-size: 1.2rem;
      border-bottom: 1px solid #444;
      padding-bottom: 3px;
    }
    .alert-toggle {
      cursor: pointer;
      display: flex;
      align-items: center;
      border: 1px solid white;
      padding: 10px 10px;
      border-radius: 5px;
      background-color: rgba(255, 255, 255, 0.1);
      color: white;
      font-family: 'Bebas Neue', sans-serif;
      font-size: 2.5rem;
      margin-bottom: 5px;
      transition: background-color 0.3s ease;
    }
    .alert-toggle:hover {
      background-color: rgba(255, 255, 255, 0.483);
    }
    .toggle-icon {
      margin-right: 5px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: green;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 0.8rem;
    }
    .toggle-icon.disabled {
      background-color: red;
    }
    
    /* Alert Count Bar (Unchanged) */
    #alert-count-bar {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      background: rgba(0, 0, 0, 0);
      position: fixed;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: 150px;
      font-family: 'Bebas Neue', sans-serif;
      font-size: 3.8rem;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      color: white;
      z-index: 100;
    }
    .alert-count {
      padding: 76px 108px;
      margin: 0;
      border-right: 0px solid white;
    }
    .alert-count:last-child {
      border-right: none;
    }
    .tornado { background-color: red; }
    .severe-thunderstorm { background-color: orange; }
    .flood-alert { background-color: #0000ff; }
    .winter-weather { background-color: #3075FF; }
    
    /* Display Elements for Alerts */
    #event-text {
      position: fixed;
      top: 95%;
      left: -30.8%;
      color: white;
      font-size: 4rem;
      font-weight: bold;
      font-family: 'Bebas Neue', sans-serif;
      text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.8);
      opacity: 1;
      transition: opacity 1s ease-in-out;
    }
    #area-text {
      position: fixed;
      top: 95%;
      left: 22%;
      color: white;
      font-size: 4rem;
      font-weight: bold;
      font-family: 'Bebas Neue', sans-serif;
      text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.8);
      opacity: 1;
      transition: opacity 1s ease-in-out;
    }
    #expire-date-container {
      position: fixed;
      bottom: 6.4%;
      right: 85%;
      background: rgba(255, 255, 255, 0);
      width: 330.641px;
      height: 20px;
      padding: 10px;
      border: 0;
      text-align: center;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #expire-date {
      color: black;
      font-size: 2.8rem;
      font-family: 'Bebas Neue', sans-serif;
      font-weight: bold;
      text-align: center;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <!-- Menu Icon -->
  <div id="menu-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
  
  <!-- Sidebar Menu with Grouped Toggle Icons -->
  <div id="alert-menu">
    <div class="menu-group">
      <h3>Tornado Alerts</h3>
      <div class="alert-toggle" data-type="tornado warning">
        <span class="toggle-icon">ON</span>
        <span>Tornado Warning</span>
      </div>
      <div class="alert-toggle" data-type="observed tornado warning">
        <span class="toggle-icon">ON</span>
        <span>Observed Tornado Warning</span>
      </div>
      <div class="alert-toggle" data-type="pds tornado warning">
        <span class="toggle-icon">ON</span>
        <span>PDS Tornado Warning</span>
      </div>
      <div class="alert-toggle" data-type="tornado emergency">
        <span class="toggle-icon">ON</span>
        <span>Tornado Emergency</span>
      </div>
      <div class="alert-toggle" data-type="tornado watch">
        <span class="toggle-icon">ON</span>
        <span>Tornado Watch</span>
      </div>
    </div>
    <div class="menu-group">
      <h3>Flash Flood Alerts</h3>
      <div class="alert-toggle" data-type="flash flood warning">
        <span class="toggle-icon">ON</span>
        <span>Flash Flood Warning</span>
      </div>
      <div class="alert-toggle" data-type="considerable flash flood warning">
        <span class="toggle-icon">ON</span>
        <span>Considerable Flash Flood Warning</span>
      </div>
      <div class="alert-toggle" data-type="flash flood emergency">
        <span class="toggle-icon">ON</span>
        <span>Flash Flood Emergency</span>
      </div>
      <div class="alert-toggle" data-type="flash flood watch">
        <span class="toggle-icon">ON</span>
        <span>Flash Flood Watch</span>
      </div>
      <div class="alert-toggle" data-type="flood watch">
        <span class="toggle-icon">ON</span>
        <span>Flood Watch</span>
      </div>
    </div>
    <div class="menu-group">
      <h3>Severe Thunderstorm Alerts</h3>
      <div class="alert-toggle" data-type="severe thunderstorm warning">
        <span class="toggle-icon">ON</span>
        <span>Severe Thunderstorm Warning</span>
      </div>
      <div class="alert-toggle" data-type="considerable severe thunderstorm warning">
        <span class="toggle-icon">ON</span>
        <span>Considerable Severe Thunderstorm Warning</span>
      </div>
      <div class="alert-toggle" data-type="destructive severe thunderstorm warning">
        <span class="toggle-icon">ON</span>
        <span>Destructive Severe Thunderstorm Warning</span>
      </div>
      <div class="alert-toggle" data-type="severe thunderstorm watch">
        <span class="toggle-icon">ON</span>
        <span>Severe Thunderstorm Watch</span>
      </div>
    </div>
    <div class="menu-group">
      <h3>Winter & Blizzard Alerts</h3>
      <div class="alert-toggle" data-type="winter storm warning">
        <span class="toggle-icon">ON</span>
        <span>Winter Storm Warning</span>
      </div>
      <div class="alert-toggle" data-type="blizzard warning">
        <span class="toggle-icon">ON</span>
        <span>Blizzard Warning</span>
      </div>
      <div class="alert-toggle" data-type="winter storm watch">
        <span class="toggle-icon">ON</span>
        <span>Winter Storm Watch</span>
      </div>
    </div>
    <div class="menu-group">
      <h3>Hurricane Alerts</h3>
      <div class="alert-toggle" data-type="hurricane warning">
        <span class="toggle-icon">ON</span>
        <span>Hurricane Warning</span>
      </div>
      <div class="alert-toggle" data-type="hurricane watch">
        <span class="toggle-icon">ON</span>
        <span>Hurricane Watch</span>
      </div>
    </div>
    <div class="menu-group">
      <h3>Other Alerts</h3>
      <div class="alert-toggle" data-type="snow squall warning">
        <span class="toggle-icon">ON</span>
        <span>Snow Squall Warning</span>
      </div>
      <div class="alert-toggle" data-type="tropical storm warning">
        <span class="toggle-icon">ON</span>
        <span>Tropical Storm Warning</span>
      </div>
      <div class="alert-toggle" data-type="tropical storm watch">
        <span class="toggle-icon">ON</span>
        <span>Tropical Storm Watch</span>
      </div>
    </div>
  </div>
  
  <!-- Alert Count Bar -->
  <div id="alert-count-bar">
    <div class="alert-count tornado">TORNADO WARNINGS: 0</div>
    <div class="alert-count severe-thunderstorm">SEVERE THUNDERSTORM WARNINGS: 0</div>
    <div class="alert-count flood-alert">FLOOD ALERTS: 0</div>
    <div class="alert-count winter-weather">WINTER WEATHER ALERTS: 0</div>
  </div>
  
  <!-- Display Elements for Alerts -->
  <div id="event-text" style="text-align: center; width:83%;"></div>
  <div id="area-text"></div>
  <div id="expire-date-container">
    <div id="expire-date">Expires in: N/A</div>
  </div>
  
  <script>
    // Global alert toggle settings â€“ all toggles are enabled by default.
    let alertToggles = {
      "tornado warning": true,
      "observed tornado warning": true,
      "pds tornado warning": true,
      "tornado emergency": true,
      "tornado watch": true,
      "flash flood warning": true,
      "considerable flash flood warning": true,
      "flash flood emergency": true,
      "flash flood watch": true,
      "flood watch": true,
      "severe thunderstorm warning": true,    // Generic Severe TSW
      "considerable severe thunderstorm warning": true,
      "destructive severe thunderstorm warning": true,
      "severe thunderstorm watch": true,
      "winter storm warning": true,
      "blizzard warning": true,
      "winter storm watch": true,
      "hurricane warning": true,
      "hurricane watch": true,
      "snow squall warning": true,
      "tropical storm warning": true,
      "tropical storm watch": true
    };
    
    // Variables for sequential display.
    let currentAlertIndex = 0;
    let currentAreaIndex = 0;
    let selectedBackground = "";
    
    // Global caching.
    let cachedAlerts = [];
    let lastUpdateTime = 0;
    
    // Fetch and parse alerts from the API.
    async function fetchWeatherAlerts() {
      try {
        const response = await fetch('https://api.weather.gov/alerts/active.atom?urgency=Past%2CFuture%2CExpected%2CImmediate');
        const text = await response.text();
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(text, "application/xml");
        let entries = [];
        const xpathResult = xmlDoc.evaluate("//*[local-name()='entry']", xmlDoc, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
        for (let i = 0; i < xpathResult.snapshotLength; i++) {
          entries.push(xpathResult.snapshotItem(i));
        }
        // Helper function to extract text from a node.
        function getText(node, tagName) {
          const result = node.ownerDocument.evaluate(
            `.//*[local-name()='${tagName}']`,
            node,
            null,
            XPathResult.STRING_TYPE,
            null
          );
          return result.stringValue.trim();
        }
        const alerts = entries.map(entry => {
          const eventType = getText(entry, "event") || "Unknown Event";
          const areaDesc = getText(entry, "areaDesc") || "Unknown Area";
          const expireDate = getText(entry, "expires") || "N/A";
          let parameterNodes = Array.from(entry.getElementsByTagNameNS("*", "parameter"));
          const tornadoDetection = parameterNodes.find(param => getText(param, "valueName") === "tornadoDetection")
                                    ? getText(parameterNodes.find(param => getText(param, "valueName") === "tornadoDetection"), "value")
                                    : null;
          const flashFloodDamageThreat = parameterNodes.find(param => getText(param, "valueName") === "flashFloodDamageThreat")
                                    ? getText(parameterNodes.find(param => getText(param, "valueName") === "flashFloodDamageThreat"), "value")
                                    : null;
          const tornadoDamageThreat = parameterNodes.find(param => getText(param, "valueName") === "tornadoDamageThreat")
                                    ? getText(parameterNodes.find(param => getText(param, "valueName") === "tornadoDamageThreat"), "value")
                                    : null;
          const thunderstormDamageThreat = parameterNodes.find(param => getText(param, "valueName") === "thunderstormDamageThreat")
                                    ? getText(parameterNodes.find(param => getText(param, "valueName") === "thunderstormDamageThreat"), "value")
                                    : null;
          const thunderstormDamageThreatConsiderable = thunderstormDamageThreat === "CONSIDERABLE";
          const thunderstormDamageThreatDestructive  = thunderstormDamageThreat === "DESTRUCTIVE";
          const tornadoDamageThreatCatastrophic       = tornadoDamageThreat === "CATASTROPHIC";
          const tornadoDamageThreatConsiderable       = tornadoDamageThreat === "CONSIDERABLE";
          const areaChunks = splitAreaDesc(areaDesc, 17);
          return {
            eventType,
            areaChunks,
            expireDate,
            tornadoDetection,
            flashFloodDamageThreat,
            tornadoDamageThreatCatastrophic,
            tornadoDamageThreatConsiderable,
            thunderstormDamageThreatConsiderable,
            thunderstormDamageThreatDestructive
          };
        });
        return alerts.filter(alert => {
          if (alert.expireDate === "N/A") return true;
          return new Date(alert.expireDate).getTime() > Date.now();
        });
      } catch (error) {
        console.error("Error fetching weather alerts:", error);
        return [];
      }
    }
    
    // Filtering function:
    // â€¢ If any allowed (highâ€‘priority) alerts are active, display only those.
    // â€¢ Otherwise, display every active alert (this includes winter and all other advisories).
    function filterAlerts(alerts) {
      const allowedAlerts = alerts.filter(alert =>
        alert.eventType.includes("Hurricane Warning") ||
        alert.eventType.includes("Tropical Storm Warning") ||
        alert.eventType.includes("Storm Surge Warning") ||
        alert.eventType.includes("Storm Surge Watch") ||
        alert.eventType.includes("Hurricane Watch") ||
        alert.eventType.includes("Tropical Storm Watch") ||
        alert.eventType.includes("Tornado Watch") ||
        alert.eventType.includes("Severe Thunderstorm Watch") ||
        alert.eventType.includes("Severe Thunderstorm Warning") ||
        alert.eventType.includes("Tornado Warning") ||
        alert.eventType.includes("Flash Flood Warning")
      );
      if (allowedAlerts.length > 0) {
        return allowedAlerts;
      } else {
        return alerts;
      }
    }
    
    // Split the area description into chunks with a maximum number of words per chunk.
    function splitAreaDesc(areaDesc, maxWords) {
      const parts = areaDesc.split(";");
      const chunks = [];
      let currentChunk = [];
      for (let part of parts) {
        const wordCount = (currentChunk.join(" ") + " " + part).trim().split(/\s+/).length;
        if (wordCount > maxWords && currentChunk.length > 0) {
          chunks.push(currentChunk.join("; "));
          currentChunk = [];
        }
        currentChunk.push(part.trim());
      }
      if (currentChunk.length > 0) {
        chunks.push(currentChunk.join("; "));
      }
      return chunks;
    }
    // Filtering based on user toggles.
    function applyUserToggles(alerts) {
      return alerts.filter(alert => {
        const eventTypeLower = alert.eventType.toLowerCase();
        if (eventTypeLower.includes("flash flood warning")) {
          if (alert.flashFloodDamageThreat === "CATASTROPHIC") {
            if (!alertToggles["flash flood emergency"]) return false;
          } else if (alert.flashFloodDamageThreat === "CONSIDERABLE") {
            if (!alertToggles["considerable flash flood warning"]) return false;
          } else {
            if (!alertToggles["flash flood warning"]) return false;
          }
        }
        if (eventTypeLower.includes("flash flood emergency") && !alertToggles["flash flood emergency"]) return false;
        if (eventTypeLower.includes("tornado emergency") && !alertToggles["tornado emergency"]) return false;
        if (eventTypeLower.includes("observed tornado warning") && !alertToggles["observed tornado warning"]) return false;
        if (!eventTypeLower.includes("observed") && eventTypeLower.includes("tornado warning") && !alertToggles["tornado warning"]) return false;
        if (eventTypeLower.includes("pds tornado warning") && !alertToggles["pds tornado warning"]) return false;
        if (eventTypeLower.includes("tornado watch") && !alertToggles["tornado watch"]) return false;
        
        if (eventTypeLower.includes("severe thunderstorm warning")) {
          if (alert.thunderstormDamageThreatConsiderable) {
            if (!alertToggles["considerable severe thunderstorm warning"]) return false;
          } else if (alert.thunderstormDamageThreatDestructive) {
            if (!alertToggles["destructive severe thunderstorm warning"]) return false;
          } else {
            if (!alertToggles["severe thunderstorm warning"]) return false;
          }
        }
        if (eventTypeLower.includes("severe thunderstorm watch") && !alertToggles["severe thunderstorm watch"]) return false;
        if (eventTypeLower.includes("winter storm warning") && !alertToggles["winter storm warning"]) return false;
        if (eventTypeLower.includes("blizzard warning") && !alertToggles["blizzard warning"]) return false;
        if (eventTypeLower.includes("winter storm watch") && !alertToggles["winter storm watch"]) return false;
        if (eventTypeLower.includes("hurricane warning") && !alertToggles["hurricane warning"]) return false;
        if (eventTypeLower.includes("hurricane watch") && !alertToggles["hurricane watch"]) return false;
        if (eventTypeLower.includes("snow squall warning") && !alertToggles["snow squall warning"]) return false;
        if (eventTypeLower.includes("tropical storm warning") && !alertToggles["tropical storm warning"]) return false;
        if (eventTypeLower.includes("tropical storm watch") && !alertToggles["tropical storm watch"]) return false;
        if (eventTypeLower.includes("flood watch") && !alertToggles["flood watch"]) return false;
        return true;
      });
    }
    
    // Split area description into chunks.
    function splitAreaDesc(areaDesc, maxWords) {
      const parts = areaDesc.split(";");
      const chunks = [];
      let currentChunk = [];
      for (let part of parts) {
        const wordCount = (currentChunk.join(" ") + " " + part).trim().split(/\s+/).length;
        if (wordCount > maxWords && currentChunk.length > 0) {
          chunks.push(currentChunk.join("; "));
          currentChunk = [];
        }
        currentChunk.push(part.trim());
      }
      if (currentChunk.length > 0) {
        chunks.push(currentChunk.join("; "));
      }
      return chunks;
    }
    
    // Calculate minutes until expiration.
    function calculateMinutesUntilExpiration(expireDate) {
      if (expireDate === "N/A") return "N/A";
      const expireTime = new Date(expireDate).getTime();
      const minutesLeft = Math.max(Math.floor((expireTime - Date.now()) / (1000 * 60)), 0);
      return `${minutesLeft} minute(s)`;
    }
    
    // Calculate alert counts for header display.
    function calculateAlertCounts(alerts) {
      const counts = { tornado: 0, severeThunderstorm: 0, flood: 0, winterWeather: 0 };
      alerts.forEach(alert => {
        const type = alert.eventType.toLowerCase();
        if (type.includes("tornado warning")) counts.tornado++;
        if (type.includes("severe thunderstorm warning")) counts.severeThunderstorm++;
        if (type.includes("flash flood warning") || type.includes("flood alert")) counts.flood++;
        if (type.includes("winter weather")) counts.winterWeather++;
      });
      return counts;
    }
    
    // Update header display.
    function updateAlertCounts(alerts) {
      const counts = calculateAlertCounts(alerts);
      document.querySelector(".tornado").textContent = `TORNADO WARNINGS: ${counts.tornado}`;
      document.querySelector(".severe-thunderstorm").textContent = `SEVERE THUNDERSTORM WARNINGS: ${counts.severeThunderstorm}`;
      document.querySelector(".flood-alert").textContent = `FLOOD ALERTS: ${counts.flood}`;
      document.querySelector(".winter-weather").textContent = `WINTER WEATHER ALERTS: ${counts.winterWeather}`;
    }
    
    // Determine background image based on alert priority.
    function determineBackground(alerts) {
      if (alerts.length === 0) {
        console.log("No active alertsâ€”returning 'No Weather Alerts.png'");
        return "No Weather Alerts.png";
      }
      if (alerts.some(alert => alert.tornadoDetection === "OBSERVED" && alert.tornadoDamageThreatCatastrophic)) {
        return "TORE.png";
      }
      if (alerts.some(alert =>
          alert.eventType.toLowerCase().includes("pds tornado warning") ||
          ((alert.tornadoDetection === "OBSERVED" || alert.tornadoDetection === "RADAR INDICATED") &&
           alert.tornadoDamageThreatConsiderable)
      )) {
        return "PDS TOR.png";
      }
      if (alerts.some(alert => alert.eventType.toLowerCase().includes("tornado warning"))) {
        return "TOR.png";
      }
      if (alerts.some(alert =>
          alert.eventType.toLowerCase().includes("flash flood warning") &&
          alert.flashFloodDamageThreat === "CATASTROPHIC"
      )) {
        return "FFWE.png";
      }
      if (alerts.some(alert =>
          alert.thunderstormDamageThreatDestructive &&
          alert.eventType.toLowerCase().includes("severe thunderstorm warning")
      )) {
        return "PDS SVR.png";
      }
      if (alerts.some(alert => alert.eventType.toLowerCase().includes("huricane warning"))) {
        return "HUW.png";
      }
      if (alerts.some(alert => alert.eventType.toLowerCase().includes("severe thunderstorm warning"))) {
        return "SVR.png";
      }
      if (alerts.some(alert =>
          alert.eventType.toLowerCase().includes("flash flood warning") &&
          alert.flashFloodDamageThreat === "CONSIDERABLE"
      )) {
        return "FFW - Considerable.png";
      }
      if (alerts.some(alert => alert.eventType.toLowerCase().includes("flash flood warning"))) {
        return "FFW.png";
      }
      if (alerts.some(alert => alert.eventType.toLowerCase().includes("tropical storm warning"))) {
        return "TSW.png";
      }
      if (alerts.some(alert => alert.eventType.toLowerCase().includes("snow squall warning"))) {
        return "SQW.png";
      }
      if (alerts.some(alert => alert.eventType.toLowerCase().includes("tornado watch"))) {
        return "TOA.png";
      }
      if (alerts.some(alert => alert.eventType.toLowerCase().includes("blizzard warning"))) {
        return "BZW.png";
      }
      if (alerts.some(alert => alert.eventType.toLowerCase().includes("winter storm warning"))) {
        return "WSW.png";
      }
      if (alerts.some(alert => alert.eventType.toLowerCase().includes("severe thunderstorm watch"))) {
        return "SVA.png";
      }
      if (alerts.some(alert => alert.eventType.toLowerCase().includes("winter storm watch"))) {
        return "WSA.png";
      }
      if (alerts.some(alert =>
          alert.eventType.toLowerCase().includes("special weather statement") ||
          alert.eventType.toLowerCase().includes("sws")
      )) {
        return "SWS.png";
      }
      return "AlertActive.png";
    }
    
    // Update background image.
    function updateBackground(image) {
      if (selectedBackground !== image) {
        selectedBackground = image;
        document.body.style.background = `url('${image}') no-repeat center center fixed`;
        document.body.style.backgroundSize = "cover";
        console.log("Background updated to:", image);
      }
    }
    
    // Display alerts sequentially.
    async function displayAlertsSequentially(alerts) {
      const eventElement = document.getElementById("event-text");
      const areaElement = document.getElementById("area-text");
      const expireDateElement = document.getElementById("expire-date");
      
      const bgImage = determineBackground(alerts);
      updateBackground(bgImage);
      
      if (alerts.length === 0) {
        eventElement.textContent = "No Active Weather Alerts";
        areaElement.textContent = "";
        expireDateElement.textContent = "";
        return;
      }
      
      if (bgImage === "AlertActive.png") {
        eventElement.textContent = alerts.map(a => a.eventType).join(" | ");
        areaElement.textContent = alerts.map(a => a.areaChunks.join(" | ")).join(" | ");
        expireDateElement.textContent = "";
        return;
      }
      
      const alert = alerts[currentAlertIndex];
      const currentChunk = alert.areaChunks[currentAreaIndex];
      const minutesLeft = calculateMinutesUntilExpiration(alert.expireDate);
      
      eventElement.style.opacity = 0;
      areaElement.style.opacity = 0;
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Tornado branch:
      if (alert.eventType.toLowerCase().includes("tornado warning")) {
        if (alert.tornadoDamageThreatCatastrophic) {
          eventElement.textContent = "Tornado Emergency";
        } else if (alert.tornadoDamageThreatConsiderable) {
          eventElement.textContent = "PDS Tornado Warning";
        } else if (alert.tornadoDetection === "OBSERVED") {
          eventElement.textContent = "Observed Tornado Warning";
        } else if (alert.tornadoDetection === "RADAR INDICATED") {
          eventElement.textContent = "Tornado Warning";
        } else {
          eventElement.textContent = alert.eventType;
        }
      }
      // Flash Flood branch:
      else if (alert.eventType.toLowerCase().includes("flash flood warning") && alert.flashFloodDamageThreat === "CATASTROPHIC") {
        eventElement.textContent = "Flash Flood Emergency";
      }
      // Severe Thunderstorm branch:
      else if (alert.eventType.toLowerCase().includes("severe thunderstorm warning")) {
        if (alert.thunderstormDamageThreatConsiderable) {
          eventElement.textContent = "Severe Thunderstorm Warning";
        } else if (alert.thunderstormDamageThreatDestructive) {
          eventElement.textContent = "Severe Thunderstorm Warning";
        } else {
          eventElement.textContent = alert.eventType;
        }
      }
      else {
        eventElement.textContent = alert.eventType;
      }
      
      // Area text display:
      if (alert.eventType.toLowerCase().includes("tornado warning") && alert.tornadoDetection === "RADAR INDICATED") {
        areaElement.textContent = `Radar Indicated: ${currentChunk}`;
      } else if (alert.eventType.toLowerCase().includes("severe thunderstorm warning")) {
        if (alert.thunderstormDamageThreatConsiderable) {
          areaElement.textContent = `Considerable: ${currentChunk}`;
        } else if (alert.thunderstormDamageThreatDestructive) {
          areaElement.textContent = `Destructive: ${currentChunk}`;
        } else {
          areaElement.textContent = currentChunk;
        }
      } else if (alert.eventType.toLowerCase().includes("flash flood warning") && alert.flashFloodDamageThreat === "CONSIDERABLE") {
        areaElement.textContent = `Considerable: ${currentChunk}`;
      } else {
        areaElement.textContent = currentChunk;
      }
      
      expireDateElement.textContent = `Expires in: ${minutesLeft}`;
      
      eventElement.style.opacity = 1;
      areaElement.style.opacity = 1;
      
      await new Promise(resolve => setTimeout(resolve, 5000));
      currentAreaIndex++;
      if (currentAreaIndex >= alert.areaChunks.length) {
        currentAreaIndex = 0;
        currentAlertIndex++;
        if (currentAlertIndex >= alerts.length) {
          currentAlertIndex = 0;
        }
      }
    }
    
    // Main update function.
    async function updateBackgroundCycle() {
      const alertsRaw = await fetchWeatherAlerts();
      let filteredAlerts = filterAlerts(alertsRaw);
      
      filteredAlerts = applyUserToggles(filteredAlerts);
      
      if (filteredAlerts.length > 0) {
        cachedAlerts = filteredAlerts;
        lastUpdateTime = Date.now();
      } else if (cachedAlerts.length > 0 && (Date.now() - lastUpdateTime) < (10 * 60 * 1000)) {
        console.log("Using cached alerts");
      }
      
      const alertsToDisplay = filteredAlerts.length > 0 ? filteredAlerts : cachedAlerts;
      
      updateAlertCounts(alertsToDisplay);
      console.log("Active Alerts Count:", alertsToDisplay.length);
      await displayAlertsSequentially(alertsToDisplay);
    }
    
    // Toggle event listeners.
    document.querySelectorAll('.alert-toggle').forEach(toggle => {
      toggle.addEventListener('click', () => {
        const type = toggle.getAttribute('data-type');
        alertToggles[type] = !alertToggles[type];
        const icon = toggle.querySelector('.toggle-icon');
        if (alertToggles[type]) {
          icon.classList.remove('disabled');
          icon.textContent = "ON";
        } else {
          icon.classList.add('disabled');
          icon.textContent = "OFF";
        }
      });
    });
    
    // Menu icon toggle for the dropdown menu.
    document.getElementById("menu-icon").addEventListener("click", function() {
      const menu = document.getElementById("alert-menu");
      // Toggle display between "block" and "none"
      if (menu.style.display === "none" || menu.style.display === "") {
        menu.style.display = "block";
      } else {
        menu.style.display = "none";
      }
    });
    
    // Update cycle.
    setInterval(updateBackgroundCycle, 5000);
    updateBackgroundCycle();
  </script>
</body>
</html>
