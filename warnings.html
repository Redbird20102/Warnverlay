<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Weather Warning Overlay</title>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet" />
  <style>
    body { font-family: Arial, sans-serif; }

    #overlay {
      display: none;
      position: fixed;
      top: 0; left: -10;
      width: 120%; height: 120%;
      background-color: rgba(0,0,0,0);
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 9999;
    }

    #overlay img {
      max-width: 120%; max-height: 120%;
      opacity: 1;
      transition: opacity 2s ease-in-out;
    }

    .text-container {
      position: absolute;
      font-size: 2.6rem;
      font-weight: bold;
      font-family: 'Bebas Neue', sans-serif;
      text-align: center;
      opacity: 0;
      transition: opacity 2s ease-in-out;
      color: rgb(255,255,255);
    }

    /* Severe Thunderstorm Warning */
    .severe#testWarningContainer {
      top: 73%; left: 64.5%;
      transform: translate(-50%, -50%);
      color: rgb(255, 255, 255);
    }
    .severe#testCountyContainer {
      top: 77%; left: 64.5%;
      transform: translate(-50%, -50%);
      color: rgb(255, 255, 255);
      font-size: 1.7rem;
    }
    .considerableSevere#testWarningContainer { color: rgb(255, 255, 255) !important; }
    .considerableSevere#testCountyContainer { color: rgb(255, 255, 255) !important; }
    .destructiveSevere#testWarningContainer { color: rgb(255, 255, 255) !important; }
    .destructiveSevere#testCountyContainer { color: rgb(255, 255, 255) !important; }

    /* Flash Flood Warning */
    .flashFlood#testWarningContainer {
      top: 73%; left: 64.5%;
      transform: translate(-50%, -50%);
      color: rgb(255, 255, 255);
    }
    .flashFlood#testCountyContainer {
      top: 77%; left: 64.5%;
      transform: translate(-50%, -50%);
      color: rgb(255, 255, 255);
      font-size: 1.7rem;
    }
    .considerableFlashFlood#testWarningContainer { color: rgba(255, 255, 255, 1) !important; }
    .considerableFlashFlood#testCountyContainer { color: rgb(255, 255, 255) !important; }
    .catastrophicFlashFlood#testWarningContainer { color: rgb(255, 255, 255) !important; }
    .catastrophicFlashFlood#testCountyContainer { color: rgb(255, 255, 255) !important; }

    /* Tornado Warning */
    .tornado#testWarningContainer {
      top: 73%; left: 64.5%;
      transform: translate(-50%, -50%);
      color: rgb(255, 255, 255);
    }
    .tornado#testCountyContainer {
      top: 77%; left: 64.5%;
      transform: translate(-50%, -50%);
      color: rgb(255, 255, 255);
      font-size: 1.7rem;
    }
    .pdsTornado#testWarningContainer { color: rgb(255, 255, 255) !important; }
    .pdsTornado#testCountyContainer { color: rgb(255, 255, 255) !important; }
    .tornadoEmergency#testWarningContainer { color: rgb(255, 255, 255) !important; }
    .tornadoEmergency#testCountyContainer { color: rgb(255, 255, 255) !important; }

    /* Menu styles with glowing and light sweep effects */
    @keyframes glow-pulse {
      0% { box-shadow: 0 0 10px rgba(255, 50, 50, 0.5), inset 0 0 10px rgba(255, 50, 50, 0.2); }
      50% { box-shadow: 0 0 20px rgba(255, 50, 50, 0.8), inset 0 0 15px rgba(255, 50, 50, 0.3); }
      100% { box-shadow: 0 0 10px rgba(255, 50, 50, 0.5), inset 0 0 10px rgba(255, 50, 50, 0.2); }
    }
    @keyframes light-sweep {
      0% { left: -100%; }
      100% { left: 100%; }
    }
    @keyframes menu-glow {
      0%, 100% { box-shadow: 0 0 15px rgba(255, 50, 50, 0.6), 0 0 30px rgba(255, 50, 50, 0.3), inset 0 0 20px rgba(255, 50, 50, 0.1); }
      50% { box-shadow: 0 0 25px rgba(255, 50, 50, 0.9), 0 0 40px rgba(255, 50, 50, 0.5), inset 0 0 30px rgba(255, 50, 50, 0.2); }
    }
    #menu-icon {
      position: fixed;
      top: 10px;
      left: 10px;
      width: 40px;
      height: 40px;
      cursor: pointer;
      z-index: 10000;
      background: linear-gradient(135deg, rgba(100, 20, 20, 0.8), rgba(150, 50, 50, 0.8));
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: glow-pulse 2s ease-in-out infinite;
      border: 2px solid rgba(255, 50, 50, 0.6);
      transition: all 0.3s ease;
    }
    #menu-icon:hover {
      box-shadow: 0 0 30px rgba(255, 50, 50, 1), 0 0 60px rgba(255, 50, 50, 0.5);
      border-color: rgba(255, 100, 100, 1);
    }
    #menu-icon span {
      display: block;
      width: 24px;
      height: 3px;
      background: white;
      margin: 3px 0;
      transition: 0.4s;
      box-shadow: 0 0 5px rgba(255, 50, 50, 0.8);
    }
    #alert-menu {
      position: fixed;
      top: 60px;
      left: 10px;
      width: 280px;
      background: linear-gradient(135deg, rgba(80, 10, 10, 0.95), rgba(120, 20, 20, 0.95));
      padding: 15px;
      border-radius: 8px;
      z-index: 9000;
      display: none;
      max-height: 80vh;
      overflow-y: scroll;
      color: white;
      border: 1.5px solid rgba(255, 50, 50, 0.5);
      animation: menu-glow 3s ease-in-out infinite;
      box-shadow: 0 0 20px rgba(255, 50, 50, 0.4), inset 0 0 20px rgba(255, 50, 50, 0.1);
      overflow-x: hidden;
      position: relative;
      scrollbar-width: thin;
      scrollbar-color: rgba(255, 50, 50, 0.8) rgba(80, 10, 10, 0.5);
    }
    #alert-menu::-webkit-scrollbar {
      width: 12px;
    }
    #alert-menu::-webkit-scrollbar-track {
      background: rgba(80, 10, 10, 0.5);
      border-radius: 6px;
    }
    #alert-menu::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(255, 100, 100, 0.8), rgba(255, 50, 50, 0.8));
      border-radius: 6px;
      box-shadow: 0 0 10px rgba(255, 50, 50, 0.6), inset 0 0 5px rgba(255, 100, 100, 0.4);
      border: 1px solid rgba(255, 50, 50, 0.6);
    }
    #alert-menu::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(255, 150, 150, 1), rgba(255, 80, 80, 1));
      box-shadow: 0 0 20px rgba(255, 50, 50, 0.9), inset 0 0 8px rgba(255, 150, 150, 0.6);
    }
    #alert-menu::-webkit-scrollbar-thumb:active {
      background: linear-gradient(180deg, rgba(255, 200, 200, 1), rgba(255, 100, 100, 1));
      box-shadow: 0 0 25px rgba(255, 50, 50, 1), inset 0 0 10px rgba(255, 200, 200, 0.8);
    }
    .menu-group {
      margin-bottom: 20px;
      position: relative;
      z-index: 1;
    }
    .menu-group h3 {
      margin: 10px 0 8px;
      font-family: 'Bebas Neue', sans-serif;
      font-size: 1.1rem;
      border-bottom: 2px solid rgba(255, 50, 50, 0.6);
      padding-bottom: 5px;
      color: rgba(255, 100, 100, 1);
      text-shadow: 0 0 10px rgba(255, 50, 50, 0.6);
    }
    .alert-toggle {
      cursor: pointer;
      display: flex;
      align-items: center;
      border: 1.5px solid rgba(255, 50, 50, 0.5);
      padding: 8px 12px;
      border-radius: 6px;
      background: linear-gradient(135deg, rgba(150, 50, 50, 0.3), rgba(130, 30, 30, 0.3));
      color: white;
      font-family: 'Bebas Neue', sans-serif;
      font-size: 0.9rem;
      margin-bottom: 6px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    .alert-toggle::before {
      content: "";
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
      transition: left 0.5s ease;
    }
    .alert-toggle:hover {
      background: linear-gradient(135deg, rgba(200, 80, 80, 0.5), rgba(170, 50, 50, 0.5));
      border-color: rgba(255, 100, 100, 0.8);
      box-shadow: 0 0 15px rgba(255, 50, 50, 0.6), inset 0 0 10px rgba(255, 50, 50, 0.2);
    }
    .alert-toggle:hover::before {
      left: 100%;
    }
    .toggle-icon {
      margin-right: 8px;
      width: 34px;
      height: 24px;
      border-radius: 4px;
      background: linear-gradient(135deg, #00ff00, #00cc00);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 0.75rem;
      font-weight: bold;
      box-shadow: 0 0 8px rgba(0, 255, 0, 0.6);
      transition: all 0.3s ease;
    }
    .toggle-icon.disabled {
      background: linear-gradient(135deg, #ff3333, #cc0000);
      box-shadow: 0 0 8px rgba(255, 0, 0, 0.6);
    }
  </style>
</head>
<body>
  <div id="overlay">
    <img id="overlayImage" src="" alt="Warning Image" />
    <audio id="overlayAudio"></audio>
    <div id="testWarningContainer" class="text-container severe"></div>
    <div id="testCountyContainer"  class="text-container severe"></div>
  </div>

  <!-- Menu (added) -->
  <div id="menu-icon">
    <span></span><span></span><span></span>
  </div>
  <div id="alert-menu">
    <div class="menu-group">
      <h3>Alert Categories</h3>
      <div class="alert-toggle" data-type="tornado">
        <span class="toggle-icon">ON</span><span>Tornado Alerts</span>
      </div>
      <div class="alert-toggle" data-type="severe">
        <span class="toggle-icon">ON</span><span>Severe Thunderstorm Alerts</span>
      </div>
      <div class="alert-toggle" data-type="flashFlood">
        <span class="toggle-icon">ON</span><span>Flash Flood Alerts</span>
      </div>
    </div>
    <div class="menu-group" id="state-group">
      <h3>State Filters</h3>
      <!-- state toggles injected here -->
    </div>
  </div>

  <script>
    let alertQueue = [], isOverlayActive = false, initialLoad = true;

    const issuedSevereAlerts       = {};
    const issuedTornadoAlerts      = {};
    const issuedFlashFloodAlerts   = {};

    const lastQueuedTime = {
      tornado: 0,
      severe: 0,
      flashFlood: 0
    };
    const throttleDelay = 0;

    function getText(node, tag) {
      return node.querySelector(tag)?.textContent || "";
    }

    // replace previous generateAlertKey with id-aware version
    const normalizeArea = area => area.toLowerCase().trim();

    function generateAlertKey(eventText, areaDesc, id) {
      // prefer using a stable id when available so two different alerts
      // with identical text/areas are not treated as the same record
      if (id) return `${eventText.toLowerCase().trim()}|${normalizeArea(areaDesc)}|id:${id}`;
      return `${eventText.toLowerCase().trim()}|${normalizeArea(areaDesc)}`;
    }

    function splitAreaDesc(areaDesc) {
      const areas = areaDesc.split(";")
        .map(a => normalizeArea(a))
        .filter(a => a)
        .sort();
      if (areas.length <= 6) return [areas.join("; ")];
      const groups = [];
      for (let i = 0; i < areas.length; i += 6) {
        groups.push(areas.slice(i, i + 6).join("; "));
      }
      return groups;
    }

    function enqueueAlert(options) {
      const { type, alertKey, force } = options;
      const issuedMap = {
        severe: issuedSevereAlerts,
        tornado: issuedTornadoAlerts,
        flashFlood: issuedFlashFloodAlerts
      }[type];

      if (issuedMap[alertKey]?.queued && !force) return;

      const now = Date.now();
      if (now - lastQueuedTime[type] < throttleDelay) return;
      lastQueuedTime[type] = now;

      alertQueue.push(options);
      if (!issuedMap[alertKey]) {
        issuedMap[alertKey] = {
          state: options.state,
          queued: true,
          lastDisplayed: options.state
        };
      } else {
        issuedMap[alertKey].queued = true;
      }
    }

    function processNextAlert() {
      if (!alertQueue.length) return;
      isOverlayActive = true;
      triggerWarning(alertQueue.shift());
    }

    function triggerWarning(opts) {
      const {
        imageSrc, audioSrc, eventText, areaDesc,
        type, pds, emergency, destructive,
        flashFloodConsiderable, flashFloodCatastrophic
      } = opts;

      const overlay            = document.getElementById("overlay");
      const overlayImage       = document.getElementById("overlayImage");
      const overlayAudio       = document.getElementById("overlayAudio");
      const testWarningContainer = document.getElementById("testWarningContainer");
      const testCountyContainer  = document.getElementById("testCountyContainer");

      testWarningContainer.removeAttribute("style");
      testCountyContainer.removeAttribute("style");
      testWarningContainer.className = "text-container";
      testCountyContainer.className  = "text-container";

      // apply styling per type
      if (type === "severe") {
        testWarningContainer.classList.add("severe");
        testCountyContainer.classList.add("severe");
        if (destructive) {
          testWarningContainer.classList.add("destructiveSevere");
          testCountyContainer.classList.add("destructiveSevere");
        } else if (opts.considerable) {
          testWarningContainer.classList.add("considerableSevere");
          testCountyContainer.classList.add("considerableSevere");
        }
      }
      else if (type === "tornado") {
        testWarningContainer.classList.add("tornado");
        testCountyContainer.classList.add("tornado");
        if (emergency) {
          testWarningContainer.classList.add("tornadoEmergency");
          testCountyContainer.classList.add("tornadoEmergency");
        } else if (pds) {
          testWarningContainer.classList.add("pdsTornado");
          testCountyContainer.classList.add("pdsTornado");
        }
      }
      else if (type === "flashFlood") {
        testWarningContainer.classList.add("flashFlood");
        testCountyContainer.classList.add("flashFlood");
        if (flashFloodCatastrophic) {
          testWarningContainer.classList.add("catastrophicFlashFlood");
          testCountyContainer.classList.add("catastrophicFlashFlood");
        } else if (flashFloodConsiderable) {
          testWarningContainer.classList.add("considerableFlashFlood");
          testCountyContainer.classList.add("considerableFlashFlood");
        }
      }

      overlayImage.src = imageSrc + "?t=" + Date.now();
      overlayImage.style.transition = "none";
      overlayImage.style.opacity = "1";
      setTimeout(() => overlayImage.style.transition = "opacity 2s ease-in-out", 50);

      if (audioSrc) {
        overlayAudio.src = audioSrc;
        overlayAudio.play().catch(() => {});
      } else {
        overlayAudio.pause();
        overlayAudio.src = "";
      }

      testWarningContainer.textContent = eventText;
      testCountyContainer.textContent  = areaDesc;
      overlay.style.display = "flex";

      setTimeout(() => {
        testWarningContainer.style.opacity = "1";
        testCountyContainer.style.opacity  = "1";
      }, 2000);
      setTimeout(() => {
        testWarningContainer.style.opacity = "0";
        testCountyContainer.style.opacity  = "0";
      }, 16000);
      setTimeout(() => {
        overlayImage.style.opacity = "0";
      }, 18700);
      setTimeout(() => {
        overlay.style.display = "none";
        overlayImage.style.opacity = "1";
        isOverlayActive = false;
        processNextAlert();
      }, 20000);
    }

    // Helper: Extract damage threats and detection from warnverlay API tags
    function extractThreatsFromWarnverlay(tags) {
      return {
        // True if detection is "RADAR INDICATED" or "OBSERVED"
        tornadoDetectionRadarIndicated: tags.TORNADO === "RADAR INDICATED",
        tornadoDetectionObserved: tags.TORNADO === "OBSERVED",
        tornadoDetection: tags.TORNADO || null,
        tornadoDamageThreatCatastrophic: tags.TORNADO_DAMAGE_THREAT === "CATASTROPHIC",
        tornadoDamageThreatConsiderable: tags.TORNADO_DAMAGE_THREAT === "CONSIDERABLE",
        thunderstormDamageThreatConsiderable: tags.THUNDERSTORM_DAMAGE_THREAT === "CONSIDERABLE",
        thunderstormDamageThreatDestructive: tags.THUNDERSTORM_DAMAGE_THREAT === "DESTRUCTIVE",
        flashFloodDamageThreat: (tags.FLASH_FLOOD_DAMAGE_THREAT === "CATASTROPHIC" || tags.FLASH_FLOOD_DAMAGE_THREAT === "CONSIDERABLE")
          ? tags.FLASH_FLOOD_DAMAGE_THREAT : null
      };
    }

    // Helper: Extract damage threats and detection from Atom API parameters (fallback)
    function extractThreatsFromAtom(entry) {
      const parameters = Array.from(entry.getElementsByTagName("cap:parameter"));
      let tornadoDetection = null,
          tornadoDamageThreatCatastrophic = false,
          tornadoDamageThreatConsiderable = false,
          thunderstormDamageThreatConsiderable = false,
          thunderstormDamageThreatDestructive = false,
          flashFloodDamageThreat = null;

      parameters.forEach(p => {
        const name = p.querySelector("valueName")?.textContent || "";
        const val  = p.querySelector("value")?.textContent || "";
        if (name === "tornadoDetection") {
          tornadoDetection = val;
        }
        if (name === "tornadoDamageThreat") {
          if (val === "CATASTROPHIC") tornadoDamageThreatCatastrophic = true;
          if (val === "CONSIDERABLE") tornadoDamageThreatConsiderable = true;
        }
        if (name === "thunderstormDamageThreat") {
          if (val === "CONSIDERABLE") thunderstormDamageThreatConsiderable = true;
          if (val === "DESTRUCTIVE") thunderstormDamageThreatDestructive = true;
        }
        if (name === "flashFloodDamageThreat") {
          if (val === "CATASTROPHIC" || val === "CONSIDERABLE") flashFloodDamageThreat = val;
        }
      });

      return {
        tornadoDetectionRadarIndicated: tornadoDetection === "RADAR INDICATED",
        tornadoDetectionObserved: tornadoDetection === "OBSERVED",
        tornadoDetection,
        tornadoDamageThreatCatastrophic,
        tornadoDamageThreatConsiderable,
        thunderstormDamageThreatConsiderable,
        thunderstormDamageThreatDestructive,
        flashFloodDamageThreat
      };
    }

    // Fetch alerts from warnverlay API
    async function fetchWarnverlayAlerts() {
      try {
        const resp = await fetch("https://nws-api.vercel.app/");
        const data = await resp.json();
        if (!Array.isArray(data) || !data.length) return [];
        return data.map(alert => {
          const props = alert.properties || {};
          const tags = props.tags || {};
          return {
            id: props.id || undefined,
            event: props.event || "",
            areaDesc: props.areaDesc || "",
            expires: props.expires || "",
            description: props.description || "",
            threats: extractThreatsFromWarnverlay(tags),
            action: props.action || "" // <-- fetch action
          };
        });
      } catch (e) {
        return [];
      }
    }

    // Fetch alerts from NWS API (weather.gov only)
    async function fetchNWSAlerts() {
      try {
        const resp = await fetch("https://api.weather.gov/alerts/active.atom");
        const str = await resp.text();
        const parser = new DOMParser();
        const xml = parser.parseFromString(str, "application/xml");
        const entries = Array.from(xml.getElementsByTagName("entry"));
        return entries.map(entry => {
          const eventEl = entry.querySelector("cap\\:event") || entry.querySelector("event");
          const areaEl  = entry.querySelector("cap\\:areaDesc") || entry.querySelector("areaDesc");
          const descEl  = entry.querySelector("summary") || entry.querySelector("description");
          const idEl    = entry.querySelector("cap\\:identifier") || entry.querySelector("id");
          return {
            id: idEl ? (idEl.textContent || "").trim() : undefined,
            event: eventEl ? eventEl.textContent.trim() : "",
            areaDesc: areaEl ? areaEl.textContent.trim() : "",
            expires: entry.querySelector("cap\\:expires")?.textContent || "",
            description: descEl ? descEl.textContent : "",
            threats: extractThreatsFromAtom(entry)
          };
        });
      } catch (e) {
        return [];
      }
    }

    // Unified fetch function: try warnverlay, fallback to Atom
    async function fetchWeatherAlerts() {
      let alerts = await fetchWarnverlayAlerts();
      if (!alerts.length) {
        alerts = await fetchNWSAlerts();
      }
      return alerts;
    }

    // Main pollAlerts logic: use unified fetchWeatherAlerts
    async function pollAlerts() {
      if (isOverlayActive) {
        setTimeout(pollAlerts, 0);
        return;
      }

      let alerts = await fetchWeatherAlerts();
      if (!alerts.length) {
        setTimeout(pollAlerts, 1000);
        return;
      }

      const currentFeedKeys    = new Set();
      const processedThisCycle = new Set();

      alerts.forEach(alert => {
        const eventTextRaw = alert.event || "";
        const areaDesc     = alert.areaDesc || "";
        const expireDate   = alert.expires || "";
        const threats      = alert.threats;
        const action       = alert.action || ""; // <-- get action from warnverlay, empty for atom

        // Split areaDesc into groups of max 6
        const groups = splitAreaDesc(areaDesc);

        // SEVERE THUNDERSTORM WARNING
        if (eventTextRaw.toLowerCase().includes("severe thunderstorm warning") && alertCategoryToggles.severe) {
          const baseEventText = "Severe Thunderstorm Warning";
          let currentThreat = "DEFAULT";
          if (threats.thunderstormDamageThreatDestructive) currentThreat = "DESTRUCTIVE";
          else if (threats.thunderstormDamageThreatConsiderable) currentThreat = "CONSIDERABLE";

          groups.forEach(group => {
            if (!passesStateFilter(group)) return;
            const key = generateAlertKey(baseEventText, group, alert.id);
            if (processedThisCycle.has(key)) return;
            processedThisCycle.add(key);
            currentFeedKeys.add(key);

            const record = issuedSevereAlerts[key];
            if (initialLoad) {
              issuedSevereAlerts[key] = {
                state: currentThreat,
                queued: false,
                lastDisplayed: currentThreat
              };
            } else if (!record) {
              let text, img, aud;
              if (currentThreat==="DESTRUCTIVE") {
                text = "PDS Severe Thunderstorm Warning - Destructive";
                img = "PDS SVR.gif";
                aud = "PDS SVR.mp3";
              } else if (currentThreat==="CONSIDERABLE") {
                text = "Severe Thunderstorm Warning – Considerable";
                img = "SVR - Considerable.gif";
                aud = "SVR - Considerable.mp3";
              } else {
                text = "Severe Thunderstorm Warning";
                img = "SVR.gif";
                aud = "SVR.mp3";
              }

              enqueueAlert({
                alertKey: key,
                imageSrc: img,
                audioSrc: aud,
                eventText: text,
                areaDesc: group,
                type: "severe",
                state: currentThreat,
                destructive: currentThreat==="DESTRUCTIVE",
                considerable: currentThreat==="CONSIDERABLE"
              });
              issuedSevereAlerts[key] = {
                state: currentThreat,
                queued: true,
                lastDisplayed: currentThreat
              };
            } else if (record.lastDisplayed !== currentThreat) {
              let text, img, aud;
              if (action === "CON") {
                if (currentThreat==="DESTRUCTIVE") {
                  text = "PDS Severe Thunderstorm Warning - Destructive Upgraded";
                  img = "PDS SVR.gif";
                  aud = "PDS SVR.mp3";
                } else if (currentThreat==="CONSIDERABLE") {
                  text = "Severe Thunderstorm Warning – Considerable Upgraded";
                  img = "SVR - Considerable.gif";
                  aud = "SVR - Considerable Upgraded.mp3";
                }
              } else {
                if (currentThreat==="DESTRUCTIVE") {
                  text = "PDS Severe Thunderstorm Warning - Destructive";
                  img = "PDS SVR.gif";
                  aud = "PDS SVR.mp3";
                } else if (currentThreat==="CONSIDERABLE") {
                  text = "Severe Thunderstorm Warning – Considerable";
                  img = "SVR - Considerable.gif";
                  aud = "SVR - Considerable.mp3";
                } else {
                  text = "Severe Thunderstorm Warning";
                  img = "SVR.gif";
                  aud = "SVR.mp3";
                }
              }

              enqueueAlert({
                alertKey: key,
                imageSrc: img,
                audioSrc: aud,
                eventText: text,
                areaDesc: group,
                type: "severe",
                state: currentThreat,
                destructive: currentThreat==="DESTRUCTIVE",
                considerable: currentThreat==="CONSIDERABLE",
                force: true
              });
              record.lastDisplayed = currentThreat;
            }
          });
        }

        // TORNADO WARNING
        else if (eventTextRaw.toLowerCase().includes("tornado warning") && alertCategoryToggles.tornado) {
          const baseEventText = "Tornado Warning";
          let currentState = "DEFAULT";
          if (threats.tornadoDetection === "OBSERVED" && threats.tornadoDamageThreatCatastrophic) {
            currentState = "EMERGENCY";
          } else if (
            (threats.tornadoDetection === "OBSERVED" || threats.tornadoDetection === "RADAR INDICATED") &&
            threats.tornadoDamageThreatConsiderable
          ) {
            currentState = "PDS";
          } else if (threats.tornadoDetection === "OBSERVED") {
            currentState = "OBSERVED";
          }

          groups.forEach(group => {
            if (!passesStateFilter(group)) return;
            const key = generateAlertKey(baseEventText, group, alert.id);
            if (processedThisCycle.has(key)) return;
            processedThisCycle.add(key);
            currentFeedKeys.add(key);

            const record = issuedTornadoAlerts[key];
            if (initialLoad) {
              issuedTornadoAlerts[key] = {
                state: currentState,
                queued: false,
                lastDisplayed: currentState
              };
            } else if (!record) {
              let text, img, aud, pds=false, em=false;
              if (currentState==="EMERGENCY") {
                em = true; text = "Tornado Emergency"; img = "TORE.gif"; aud = "TORE.mp3";
              } else if (currentState==="PDS") {
                pds = true; text = "PDS Tornado Warning"; img = "PDS TOR.gif"; aud = "PDS TOR.mp3";
              } else if (currentState==="OBSERVED") {
                text = "Observed Tornado Warning"; img = "TOR.gif"; aud = "TOR.mp3";
              } else {
                text = "Tornado Warning"; img = "TOR.gif"; aud = "TOR.mp3";
              }

              enqueueAlert({
                alertKey: key,
                imageSrc: img,
                audioSrc: aud,
                eventText: text,
                areaDesc: group,
                type: "tornado",
                state: currentState,
                pds,
                emergency: em
              });
              issuedTornadoAlerts[key] = {
                state: currentState,
                queued: true,
                lastDisplayed: currentState
              };
            } else if (record.lastDisplayed !== currentState) {
              let text, img, aud, pds=false, em=false;
              if (action === "CON") {
                if (currentState==="EMERGENCY") {
                  em = true; text = "Tornado Emergency Upgraded"; img = "TORE.gif"; aud = "TORE Upgraded.mp3";
                } else if (currentState==="PDS") {
                  pds = true; text = "PDS Tornado Warning Upgraded"; img = "PDS TOR.gif"; aud = "PDS TOR - TOR Upgraded.mp3";
                } else if (currentState==="OBSERVED") {
                  text = "Observed Tornado Warning Upgraded"; img = "TOR.gif"; aud = "PDS TOR - TOR Upgraded.mp3";
                }
              } else {
                if (currentState==="EMERGENCY") {
                  em = true; text = "Tornado Emergency"; img = "TORE.gif"; aud = "TORE.mp3";
                } else if (currentState==="PDS") {
                  pds = true; text = "PDS Tornado Warning"; img = "PDS TOR.gif"; aud = "PDS TOR.mp3";
                } else if (currentState==="OBSERVED") {
                  text = "Observed Tornado Warning"; img = "TOR.gif"; aud = "TOR.mp3";
                } else {
                  text = "Tornado Warning"; img = "TOR.gif"; aud = "TOR.mp3";
                }
              }

              enqueueAlert({
                alertKey: key,
                imageSrc: img,
                audioSrc: aud,
                eventText: text,
                areaDesc: group,
                type: "tornado",
                state: currentState,
                pds,
                emergency: em,
                force: true
              });
              record.lastDisplayed = currentState;
            }
          });
        }

        // FLASH FLOOD WARNING
        else if (eventTextRaw.toLowerCase().includes("flash flood warning") && alertCategoryToggles.flashFlood) {
          const baseEventText = "Flash Flood Warning";
          let currentFF = "DEFAULT";
          if (threats.flashFloodDamageThreat === "CATASTROPHIC") currentFF = "CATASTROPHIC";
          else if (threats.flashFloodDamageThreat === "CONSIDERABLE") currentFF = "CONSIDERABLE";

          groups.forEach(group => {
            if (!passesStateFilter(group)) return;
            const key = generateAlertKey(baseEventText, group, alert.id);
            if (processedThisCycle.has(key)) return;
            processedThisCycle.add(key);
            currentFeedKeys.add(key);

            const record = issuedFlashFloodAlerts[key];
            if (initialLoad) {
              issuedFlashFloodAlerts[key] = {
                state: currentFF,
                queued: false,
                lastDisplayed: currentFF
              };
            } else if (!record) {
              let text, img, aud;
              if (currentFF==="CATASTROPHIC") {
                text = "Flash Flood Emergency"; img = "FFWE.gif"; aud = "FFWE.mp3";
              } else if (currentFF==="CONSIDERABLE") {
                text = "Flash Flood Warning - Considerable"; img = "FFW - Considerable.gif"; aud = "FFW - Considerable.mp3";
              } else {
                text = "Flash Flood Warning"; img = "FFW.gif"; aud = "FFW.mp3";
              }

              enqueueAlert({
                alertKey: key,
                imageSrc: img,
                audioSrc: aud,
                eventText: text,
                areaDesc: group,
                type: "flashFlood",
                state: currentFF,
                flashFloodConsiderable: currentFF==="CONSIDERABLE",
                flashFloodCatastrophic: currentFF==="CATASTROPHIC"
              });
              issuedFlashFloodAlerts[key] = {
                state: currentFF,
                queued: true,
                lastDisplayed: currentFF
              };
            } else if (record.lastDisplayed !== currentFF) {
              let text, img, aud;
              if (action === "CON") {
                if (currentFF==="CATASTROPHIC") {
                  text = "Flash Flood Emergency Upgraded"; img = "FFWE.gif"; aud = "FFWE Upgraded.mp3";
                } else if (currentFF==="CONSIDERABLE") {
                  text = "Flash Flood Warning - Considerable Upgraded"; img = "FFW - Considerable.gif"; aud = "FFW - Considerable Upgraded.mp3";
                }
              } else {
                if (currentFF==="CATASTROPHIC") {
                  text = "Flash Flood Emergency"; img = "FFWE.gif"; aud = "FFWE.mp3";
                } else if (currentFF==="CONSIDERABLE") {
                  text = "Flash Flood Warning - Considerable"; img = "FFW - Considerable.gif"; aud = "FFW - Considerable.mp3";
                } else {
                  text = "Flash Flood Warning"; img = "FFW.gif"; aud = "FFW.mp3";
                }
              }

              enqueueAlert({
                alertKey: key,
                imageSrc: img,
                audioSrc: aud,
                eventText: text,
                areaDesc: group,
                type: "flashFlood",
                state: currentFF,
                flashFloodConsiderable: currentFF==="CONSIDERABLE",
                flashFloodCatastrophic: currentFF==="CATASTROPHIC",
                force: true
              });
              record.lastDisplayed = currentFF;
            }
          });
        }

      });

      // cleanup vanished alerts
      [
        issuedSevereAlerts,
        issuedTornadoAlerts,
        issuedFlashFloodAlerts
      ].forEach(map => {
        for (let k in map) {
          if (!currentFeedKeys.has(k)) delete map[k];
        }
      });

      if (!initialLoad && !isOverlayActive && alertQueue.length) {
        processNextAlert();
      }
      if (initialLoad) {
        initialLoad = false;
      }
      setTimeout(pollAlerts, 1000);
    }

    // --- Menu/filter data and helpers (added) ---
    let alertCategoryToggles = { tornado: true, severe: true, flashFlood: true };

    let stateToggles = {
      "AL": true, "AK": true, "AZ": true, "AR": true, "CA": true,
      "CO": true, "CT": true, "DE": true, "FL": true, "GA": true,
      "HI": true, "ID": true, "IL": true, "IN": true, "IA": true,
      "KS": true, "KY": true, "LA": true, "ME": true, "MD": true,
      "MA": true, "MI": true, "MN": true, "MS": true, "MO": true,
      "MT": true, "NE": true, "NV": true, "NH": true, "NJ": true,
      "NM": true, "NY": true, "NC": true, "ND": true, "OH": true,
      "OK": true, "OR": true, "PA": true, "RI": true, "SC": true,
      "SD": true, "TN": true, "TX": true, "UT": true, "VT": true,
      "VA": true, "WA": true, "WV": true, "WI": true, "WY": true
    };

    function populateStateToggles() {
      const container = document.getElementById("state-group");
      for (let state in stateToggles) {
        const div = document.createElement("div");
        div.className = "alert-toggle";
        div.setAttribute("data-type", state);
        div.innerHTML = '<span class="toggle-icon">' + (stateToggles[state] ? "ON" : "OFF") + '</span><span>' + state + "</span>";
        container.appendChild(div);
        div.addEventListener("click", function () {
          stateToggles[state] = !stateToggles[state];
          const icon = this.querySelector(".toggle-icon");
          icon.textContent = stateToggles[state] ? "ON" : "OFF";
          icon.classList.toggle("disabled", !stateToggles[state]);
        });
      }
    }

    // category toggles
    document.querySelectorAll('#alert-menu .alert-toggle[data-type="tornado"], #alert-menu .alert-toggle[data-type="severe"], #alert-menu .alert-toggle[data-type="flashFlood"]').forEach(toggle => {
      toggle.addEventListener("click", function() {
        const type = this.getAttribute("data-type");
        alertCategoryToggles[type] = !alertCategoryToggles[type];
        const icon = this.querySelector(".toggle-icon");
        icon.textContent = alertCategoryToggles[type] ? "ON" : "OFF";
        icon.classList.toggle("disabled", !alertCategoryToggles[type]);
      });
    });

    // menu icon toggle
    document.getElementById("menu-icon").addEventListener("click", () => {
      const menu = document.getElementById("alert-menu");
      menu.style.display = window.getComputedStyle(menu).display === "none" ? "block" : "none";
    });

    populateStateToggles();

    function extractStates(areaDesc) {
      const matches = areaDesc.match(/\b[A-Za-z]{2}\b/g);
      return matches ? matches.map(m => m.toUpperCase()) : [];
    }
    function passesStateFilter(areaDesc) {
      const states = extractStates(areaDesc);
      if (states.length === 0) return true;
      return states.some(s => stateToggles[s]);
    }
    // --- end menu/filter helpers ---

    // --- MODIFIED pollAlerts logic to respect toggles ---
    async function pollAlerts() {
      if (isOverlayActive) {
        setTimeout(pollAlerts, 0);
        return;
      }

      let alerts = await fetchWeatherAlerts();
      if (!alerts.length) {
        setTimeout(pollAlerts, 1000);
        return;
      }

      const currentFeedKeys    = new Set();
      const processedThisCycle = new Set();

      alerts.forEach(alert => {
        const eventTextRaw = alert.event || "";
        const areaDesc     = alert.areaDesc || "";
        const expireDate   = alert.expires || "";
        const threats      = alert.threats;
        const action       = alert.action || ""; // <-- get action from warnverlay, empty for atom

        // Split areaDesc into groups of max 6
        const groups = splitAreaDesc(areaDesc);

        // SEVERE THUNDERSTORM WARNING
        if (eventTextRaw.toLowerCase().includes("severe thunderstorm warning") && alertCategoryToggles.severe) {
          const baseEventText = "Severe Thunderstorm Warning";
          let currentThreat = "DEFAULT";
          if (threats.thunderstormDamageThreatDestructive) currentThreat = "DESTRUCTIVE";
          else if (threats.thunderstormDamageThreatConsiderable) currentThreat = "CONSIDERABLE";

          groups.forEach(group => {
            if (!passesStateFilter(group)) return;
            const key = generateAlertKey(baseEventText, group, alert.id);
            if (processedThisCycle.has(key)) return;
            processedThisCycle.add(key);
            currentFeedKeys.add(key);

            const record = issuedSevereAlerts[key];
            if (initialLoad) {
              issuedSevereAlerts[key] = {
                state: currentThreat,
                queued: false,
                lastDisplayed: currentThreat
              };
            } else if (!record) {
              let text, img, aud;
              if (currentThreat==="DESTRUCTIVE") {
                text = "PDS Severe Thunderstorm Warning - Destructive";
                img = "PDS SVR.gif";
                aud = "PDS SVR.mp3";
              } else if (currentThreat==="CONSIDERABLE") {
                text = "Severe Thunderstorm Warning – Considerable";
                img = "SVR - Considerable.gif";
                aud = "SVR - Considerable.mp3";
              } else {
                text = "Severe Thunderstorm Warning";
                img = "SVR.gif";
                aud = "SVR.mp3";
              }

              enqueueAlert({
                alertKey: key,
                imageSrc: img,
                audioSrc: aud,
                eventText: text,
                areaDesc: group,
                type: "severe",
                state: currentThreat,
                destructive: currentThreat==="DESTRUCTIVE",
                considerable: currentThreat==="CONSIDERABLE"
              });
              issuedSevereAlerts[key] = {
                state: currentThreat,
                queued: true,
                lastDisplayed: currentThreat
              };
            } else if (record.lastDisplayed !== currentThreat) {
              let text, img, aud;
              if (action === "CON") {
                if (currentThreat==="DESTRUCTIVE") {
                  text = "PDS Severe Thunderstorm Warning - Destructive Upgraded";
                  img = "PDS SVR.gif";
                  aud = "PDS SVR.mp3";
                } else if (currentThreat==="CONSIDERABLE") {
                  text = "Severe Thunderstorm Warning – Considerable Upgraded";
                  img = "SVR - Considerable.gif";
                  aud = "SVR - Considerable Upgraded.mp3";
                }
              } else {
                if (currentThreat==="DESTRUCTIVE") {
                  text = "PDS Severe Thunderstorm Warning - Destructive";
                  img = "PDS SVR.gif";
                  aud = "PDS SVR.mp3";
                } else if (currentThreat==="CONSIDERABLE") {
                  text = "Severe Thunderstorm Warning – Considerable";
                  img = "SVR - Considerable.gif";
                  aud = "SVR - Considerable.mp3";
                } else {
                  text = "Severe Thunderstorm Warning";
                  img = "SVR.gif";
                  aud = "SVR.mp3";
                }
              }

              enqueueAlert({
                alertKey: key,
                imageSrc: img,
                audioSrc: aud,
                eventText: text,
                areaDesc: group,
                type: "severe",
                state: currentThreat,
                destructive: currentThreat==="DESTRUCTIVE",
                considerable: currentThreat==="CONSIDERABLE",
                force: true
              });
              record.lastDisplayed = currentThreat;
            }
          });
        }

        // TORNADO WARNING
        else if (eventTextRaw.toLowerCase().includes("tornado warning") && alertCategoryToggles.tornado) {
          const baseEventText = "Tornado Warning";
          let currentState = "DEFAULT";
          if (threats.tornadoDetection === "OBSERVED" && threats.tornadoDamageThreatCatastrophic) {
            currentState = "EMERGENCY";
          } else if (
            (threats.tornadoDetection === "OBSERVED" || threats.tornadoDetection === "RADAR INDICATED") &&
            threats.tornadoDamageThreatConsiderable
          ) {
            currentState = "PDS";
          } else if (threats.tornadoDetection === "OBSERVED") {
            currentState = "OBSERVED";
          }

          groups.forEach(group => {
            if (!passesStateFilter(group)) return;
            const key = generateAlertKey(baseEventText, group, alert.id);
            if (processedThisCycle.has(key)) return;
            processedThisCycle.add(key);
            currentFeedKeys.add(key);

            const record = issuedTornadoAlerts[key];
            if (initialLoad) {
              issuedTornadoAlerts[key] = {
                state: currentState,
                queued: false,
                lastDisplayed: currentState
              };
            } else if (!record) {
              let text, img, aud, pds=false, em=false;
              if (currentState==="EMERGENCY") {
                em = true; text = "Tornado Emergency"; img = "TORE.gif"; aud = "TORE.mp3";
              } else if (currentState==="PDS") {
                pds = true; text = "PDS Tornado Warning"; img = "PDS TOR.gif"; aud = "PDS TOR.mp3";
              } else if (currentState==="OBSERVED") {
                text = "Observed Tornado Warning"; img = "TOR.gif"; aud = "TOR.mp3";
              } else {
                text = "Tornado Warning"; img = "TOR.gif"; aud = "TOR.mp3";
              }

              enqueueAlert({
                alertKey: key,
                imageSrc: img,
                audioSrc: aud,
                eventText: text,
                areaDesc: group,
                type: "tornado",
                state: currentState,
                pds,
                emergency: em
              });
              issuedTornadoAlerts[key] = {
                state: currentState,
                queued: true,
                lastDisplayed: currentState
              };
            } else if (record.lastDisplayed !== currentState) {
              let text, img, aud, pds=false, em=false;
              if (action === "CON") {
                if (currentState==="EMERGENCY") {
                  em = true; text = "Tornado Emergency Upgraded"; img = "TORE.gif"; aud = "TORE Upgraded.mp3";
                } else if (currentState==="PDS") {
                  pds = true; text = "PDS Tornado Warning Upgraded"; img = "PDS TOR.gif"; aud = "PDS TOR - TOR Upgraded.mp3";
                } else if (currentState==="OBSERVED") {
                  text = "Observed Tornado Warning Upgraded"; img = "TOR.gif"; aud = "PDS TOR - TOR Upgraded.mp3";
                }
              } else {
                if (currentState==="EMERGENCY") {
                  em = true; text = "Tornado Emergency"; img = "TORE.gif"; aud = "TORE.mp3";
                } else if (currentState==="PDS") {
                  pds = true; text = "PDS Tornado Warning"; img = "PDS TOR.gif"; aud = "PDS TOR.mp3";
                } else if (currentState==="OBSERVED") {
                  text = "Observed Tornado Warning"; img = "TOR.gif"; aud = "TOR.mp3";
                } else {
                  text = "Tornado Warning"; img = "TOR.gif"; aud = "TOR.mp3";
                }
              }

              enqueueAlert({
                alertKey: key,
                imageSrc: img,
                audioSrc: aud,
                eventText: text,
                areaDesc: group,
                type: "tornado",
                state: currentState,
                pds,
                emergency: em,
                force: true
              });
              record.lastDisplayed = currentState;
            }
          });
        }

        // FLASH FLOOD WARNING
        else if (eventTextRaw.toLowerCase().includes("flash flood warning") && alertCategoryToggles.flashFlood) {
          const baseEventText = "Flash Flood Warning";
          let currentFF = "DEFAULT";
          if (threats.flashFloodDamageThreat === "CATASTROPHIC") currentFF = "CATASTROPHIC";
          else if (threats.flashFloodDamageThreat === "CONSIDERABLE") currentFF = "CONSIDERABLE";

          groups.forEach(group => {
            if (!passesStateFilter(group)) return;
            const key = generateAlertKey(baseEventText, group, alert.id);
            if (processedThisCycle.has(key)) return;
            processedThisCycle.add(key);
            currentFeedKeys.add(key);

            const record = issuedFlashFloodAlerts[key];
            if (initialLoad) {
              issuedFlashFloodAlerts[key] = {
                state: currentFF,
                queued: false,
                lastDisplayed: currentFF
              };
            } else if (!record) {
              let text, img, aud;
              if (currentFF==="CATASTROPHIC") {
                text = "Flash Flood Emergency"; img = "FFWE.gif"; aud = "FFWE.mp3";
              } else if (currentFF==="CONSIDERABLE") {
                text = "Flash Flood Warning - Considerable"; img = "FFW - Considerable.gif"; aud = "FFW - Considerable.mp3";
              } else {
                text = "Flash Flood Warning"; img = "FFW.gif"; aud = "FFW.mp3";
              }

              enqueueAlert({
                alertKey: key,
                imageSrc: img,
                audioSrc: aud,
                eventText: text,
                areaDesc: group,
                type: "flashFlood",
                state: currentFF,
                flashFloodConsiderable: currentFF==="CONSIDERABLE",
                flashFloodCatastrophic: currentFF==="CATASTROPHIC"
              });
              issuedFlashFloodAlerts[key] = {
                state: currentFF,
                queued: true,
                lastDisplayed: currentFF
              };
            } else if (record.lastDisplayed !== currentFF) {
              let text, img, aud;
              if (action === "CON") {
                if (currentFF==="CATASTROPHIC") {
                  text = "Flash Flood Emergency Upgraded"; img = "FFWE.gif"; aud = "FFWE Upgraded.mp3";
                } else if (currentFF==="CONSIDERABLE") {
                  text = "Flash Flood Warning - Considerable Upgraded"; img = "FFW - Considerable.gif"; aud = "FFW - Considerable Upgraded.mp3";
                }
              } else {
                if (currentFF==="CATASTROPHIC") {
                  text = "Flash Flood Emergency"; img = "FFWE.gif"; aud = "FFWE.mp3";
                } else if (currentFF==="CONSIDERABLE") {
                  text = "Flash Flood Warning - Considerable"; img = "FFW - Considerable.gif"; aud = "FFW - Considerable.mp3";
                } else {
                  text = "Flash Flood Warning"; img = "FFW.gif"; aud = "FFW.mp3";
                }
              }

              enqueueAlert({
                alertKey: key,
                imageSrc: img,
                audioSrc: aud,
                eventText: text,
                areaDesc: group,
                type: "flashFlood",
                state: currentFF,
                flashFloodConsiderable: currentFF==="CONSIDERABLE",
                flashFloodCatastrophic: currentFF==="CATASTROPHIC",
                force: true
              });
              record.lastDisplayed = currentFF;
            }
          });
        }

      });

      // cleanup vanished alerts
      [
        issuedSevereAlerts,
        issuedTornadoAlerts,
        issuedFlashFloodAlerts
      ].forEach(map => {
        for (let k in map) {
          if (!currentFeedKeys.has(k)) delete map[k];
        }
      });

      if (!initialLoad && !isOverlayActive && alertQueue.length) {
        processNextAlert();
      }
      if (initialLoad) {
        initialLoad = false;
      }
      setTimeout(pollAlerts, 1000);
    }

    pollAlerts();
  </script>
</body>
</html>
